// Generated by CoffeeScript 1.3.3

module('Zee Router', {
  setup: function() {
    this.router = new GameOfLife.Router();
    this.worldMock = {};
    this.landscapeMock = {
      cataclysm: function() {
        return true;
      }
    };
    this.worldStub = sinon.stub(window.GameOfLife, "World").returns(this.worldMock);
    return this.landscapeStub = sinon.stub(window.GameOfLife, "Landscape").returns(this.landscapeMock);
  },
  teardown: function() {
    this.worldStub.restore();
    return this.landscapeStub.restore();
  }
});

test('the router has a default route', function() {
  return equals(this.router.routes[""], "home");
});

test('the default route creates a world', function() {
  this.router.home();
  return equals(this.worldStub.callCount, 1);
});

test('the router creates a landscape', function() {
  this.router.home();
  return equals(this.landscapeStub.callCount, 1);
});

test('the router creates landscape using the world', function() {
  this.router.home();
  return ok(this.landscapeStub.calledWith({
    model: this.worldMock
  }));
});

module('The Landscape - experiencing a cataclysmic event', {
  setup: function() {
    this.worldMock = sinon.mock({
      evolve: function() {
        return true;
      }
    });
    this.worldMock.expects("evolve").once();
    return this.landscape = new GameOfLife.Landscape({
      model: this.worldMock.object
    });
  },
  teardown: function() {}
});

test('it should evolve the world', function() {
  this.landscape.cataclysm();
  return ok(this.worldMock.verify());
});

module('The World', {
  setup: function() {
    this.sectorSpy = sinon.spy(window.GameOfLife, "Sector");
    return this.world = new GameOfLife.World;
  },
  teardown: function() {
    return this.sectorSpy.restore();
  }
});

test('the world should populate its sectors', function() {
  return equals(this.sectorSpy.callCount, 1024, "expected 1024 sectors");
});

test('the world should assign the sector a location in the world', function() {
  ok(this.sectorSpy.calledWith({
    world: this.world,
    x: 1,
    y: 1
  }));
  return ok(this.sectorSpy.calledWith({
    world: this.world,
    x: 32,
    y: 32
  }));
});

module('The World - Finding Neighbors with no borders', {
  setup: function() {
    var neighbors;
    this.world = new GameOfLife.World;
    neighbors = this.world.findNeighbors({
      x: 5,
      y: 5
    });
    this.results = _.map(neighbors, function(neighbor) {
      return {
        x: neighbor.get("x"),
        y: neighbor.get("y")
      };
    });
    return null;
  },
  teardown: function() {}
});

test('should only find neighbors surrounding the defined coordinates', function() {
  ok(_.find(this.results, function(result) {
    return result.x === 4 && result.y === 4;
  }));
  ok(_.find(this.results, function(result) {
    return result.x === 5 && result.y === 4;
  }));
  ok(_.find(this.results, function(result) {
    return result.x === 6 && result.y === 4;
  }));
  ok(_.find(this.results, function(result) {
    return result.x === 4 && result.y === 5;
  }));
  ok(_.find(this.results, function(result) {
    return result.x === 4 && result.y === 6;
  }));
  ok(_.find(this.results, function(result) {
    return result.x === 5 && result.y === 6;
  }));
  return ok(_.find(this.results, function(result) {
    return result.x === 6 && result.y === 6;
  }));
});

module('The World - Finding Neighbors with borders', {
  setup: function() {
    var neighbors;
    this.world = new GameOfLife.World;
    neighbors = this.world.findNeighbors({
      x: 1,
      y: 1
    });
    this.results = _.map(neighbors, function(neighbor) {
      return {
        x: neighbor.get("x"),
        y: neighbor.get("y")
      };
    });
    return null;
  },
  teardown: function() {}
});

test('it should ignore border regions', function() {
  ok(_.find(this.results, function(result) {
    return result.x === 2 && result.y === 1;
  }));
  ok(_.find(this.results, function(result) {
    return result.x === 1 && result.y === 2;
  }));
  return ok(_.find(this.results, function(result) {
    return result.x === 2 && result.y === 2;
  }));
});

module('The World - Evolving', {
  setup: function() {
    this.world = new GameOfLife.World;
    this.mockSector = sinon.mock({
      evolve: function() {
        return true;
      },
      determineFate: function() {
        return true;
      },
      trigger: function() {
        return true;
      }
    });
    this.mockSector.expects("determineFate").once();
    this.mockSector.expects("evolve").once();
    this.world.models = [this.mockSector.object];
    return null;
  },
  teardown: function() {}
});

test('should tell all of the sectors determine their fate', function() {
  this.world.evolve();
  return ok(this.mockSector.verify());
});

test('should tell all of the sectors to evolve', function() {
  this.world.evolve();
  return ok(this.mockSector.verify());
});

module('God', {
  setup: function() {
    this.god = new GameOfLife.God;
    return this.mathStub = sinon.stub(Math, "random");
  },
  teardown: function() {
    return this.mathStub.restore();
  }
});

test('blessings should be random', function() {
  this.god.blessedOrCursed();
  return equals(this.mathStub.callCount, 1);
});

module('A Sector', {
  setup: function() {
    this.god = new GameOfLife.God;
    this.godSpy = sinon.stub(this.god, "blessedOrCursed").returns(true);
    this.godStub = sinon.stub(window.GameOfLife, "God").returns(this.god);
    this.sectorLandscapeSpy = sinon.spy(window.GameOfLife, "SectorLandscape");
    return this.sector = new GameOfLife.Sector;
  },
  teardown: function() {
    this.godSpy.restore();
    this.godStub.restore();
    return this.sectorLandscapeSpy.restore();
  }
});

test('should ask if its blessed or cursed', function() {
  return equals(this.godSpy.callCount, 1);
});

test('should set its state based on blessing', function() {
  return equals(this.sector.get("alive"), true);
});

test('should create a view for itself', function() {
  return ok(this.sectorLandscapeSpy.calledOnce);
});

module('A living Sector with fewer than two live neighbors', {
  setup: function() {
    this.sutSector = new GameOfLife.Sector;
    this.sutSector.set({
      alive: true
    });
    return this.liveNeighborsStub = sinon.stub(this.sutSector, "liveNeighbors").returns([{}]);
  },
  teardown: function() {
    return this.liveNeighborsStub.restore();
  }
});

test('should die, as if caused by under-population', function() {
  return equals(this.sutSector.willBeAlive(), false);
});

module('A living Sector with two live neighbors', {
  setup: function() {
    this.sutSector = new GameOfLife.Sector;
    this.sutSector.set({
      alive: true
    });
    return this.liveNeighborsStub = sinon.stub(this.sutSector, "liveNeighbors").returns([{}, {}]);
  },
  teardown: function() {
    return this.liveNeighborsStub.restore();
  }
});

test('should keep living', function() {
  return equals(this.sutSector.willBeAlive(), true);
});

module('A living Sector with three live neighbors', {
  setup: function() {
    this.sutSector = new GameOfLife.Sector;
    this.sutSector.set({
      alive: true
    });
    return this.liveNeighborsStub = sinon.stub(this.sutSector, "liveNeighbors").returns([{}, {}, {}]);
  },
  teardown: function() {
    return this.liveNeighborsStub.restore();
  }
});

test('should keep living', function() {
  return equals(this.sutSector.willBeAlive(), true);
});

module('A living Sector with more than three live neighbors', {
  setup: function() {
    this.sutSector = new GameOfLife.Sector;
    this.sutSector.set({
      alive: true
    });
    return this.liveNeighborsStub = sinon.stub(this.sutSector, "liveNeighbors").returns([{}, {}, {}, {}]);
  },
  teardown: function() {
    return this.liveNeighborsStub.restore();
  }
});

test('should die, as if by over crowding', function() {
  return equals(this.sutSector.willBeAlive(), false);
});

module('A dead Sector with exactly three live neighbors', {
  setup: function() {
    this.sutSector = new GameOfLife.Sector;
    this.sutSector.set({
      alive: false
    });
    return this.liveNeighborsStub = sinon.stub(this.sutSector, "liveNeighbors").returns([{}, {}, {}]);
  },
  teardown: function() {
    return this.liveNeighborsStub.restore();
  }
});

test('becomes a live cell, as if by reproduction', function() {
  return equals(this.sutSector.willBeAlive(), true);
});

module('A Sector with 4 living neighbors and 4 dead neighbors', {
  setup: function() {
    var fakeNeighbors;
    this.sutSector = new GameOfLife.Sector;
    this.sutSector.set({
      alive: true
    });
    fakeNeighbors = [
      {
        get: function(alive) {
          return false;
        }
      }, {
        get: function(alive) {
          return false;
        }
      }, {
        get: function(alive) {
          return false;
        }
      }, {
        get: function(alive) {
          return false;
        }
      }, {
        get: function(alive) {
          return true;
        }
      }, {
        get: function(alive) {
          return true;
        }
      }, {
        get: function(alive) {
          return true;
        }
      }, {
        get: function(alive) {
          return true;
        }
      }
    ];
    return this.neighborsStub = sinon.stub(this.sutSector, "neighbors").returns(fakeNeighbors);
  },
  teardown: function() {
    return this.neighborsStub.restore();
  }
});

test('should know that it has 4 living neighbors', function() {
  return equals(this.sutSector.liveNeighbors().length, 4);
});

module('Finding neighbors of a Sector', {
  setup: function() {
    this.sutSector = new GameOfLife.Sector({
      x: 1,
      y: 1
    });
    this.mockWorld = sinon.mock({
      findNeighbors: function(_arg) {
        _arg;
        return [];
      }
    });
    this.mockWorld.expects("findNeighbors").withArgs({
      x: 1,
      y: 1
    });
    return this.worldStub = sinon.stub(this.sutSector, "myWorld").returns(this.mockWorld.object);
  },
  teardown: function() {
    return this.worldStub.restore();
  }
});

test('the sector should ask the world who its neighbors are', function() {
  this.sutSector.neighbors();
  return ok(this.mockWorld.verify());
});

module('A Sector, when evolving', {
  setup: function() {
    this.sutSector = new GameOfLife.Sector();
    this.fateStub = sinon.stub(this.sutSector, "get");
    this.fateStub.withArgs("fate").returns(true);
    this.setSpy = sinon.spy(this.sutSector, "set");
    this.setSpy.withArgs({
      alive: true
    }, {
      silent: true
    });
    return null;
  },
  teardown: function() {
    this.fateStub.restore();
    return this.setSpy.restore();
  }
});

test('should set its alive state based on the evolution', function() {
  this.sutSector.evolve();
  return ok(this.setSpy.calledOnce);
});

module('A Sector, when determining its fate', {
  setup: function() {
    this.sutSector = new GameOfLife.Sector();
    this.willBeAliveStub = sinon.stub(this.sutSector, "willBeAlive").returns(true);
    return null;
  },
  teardown: function() {
    return this.willBeAliveStub.restore();
  }
});

test('should know if it will be alive after the evolution', function() {
  this.sutSector.determineFate();
  return equals(this.sutSector.get("fate"), true);
});
